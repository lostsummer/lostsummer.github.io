<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>$ kill -1 - Yushin</title><link href="http://www.lostsummer.love/" rel="alternate"></link><link href="http://www.lostsummer.love/feeds/yushin.atom.xml" rel="self"></link><id>http://www.lostsummer.love/</id><updated>2018-11-28T00:00:00+08:00</updated><subtitle>code less talk more :)</subtitle><entry><title>浅谈Python生成器的妙处</title><link href="http://www.lostsummer.love/posts/2018/Nov/28/201811281543.html" rel="alternate"></link><published>2018-11-28T00:00:00+08:00</published><updated>2018-11-28T00:00:00+08:00</updated><author><name>Yushin</name></author><id>tag:www.lostsummer.love,2018-11-28:/posts/2018/Nov/28/201811281543.html</id><summary type="html">&lt;p&gt;大多数使用Python的同学应该都了解生成器语法，不知道大家使用场合是什么，我想结合自己的一点粗浅经验谈谈它给我的代码带来的好处。&lt;/p&gt;
&lt;h3&gt;1.&amp;nbsp;不浪费内存 …&lt;/h3&gt;</summary><content type="html">&lt;p&gt;大多数使用Python的同学应该都了解生成器语法，不知道大家使用场合是什么，我想结合自己的一点粗浅经验谈谈它给我的代码带来的好处。&lt;/p&gt;
&lt;h3&gt;1.&amp;nbsp;不浪费内存的的逻辑分层&lt;/h3&gt;
&lt;p&gt;一个大家熟悉的例子是python2 的xrange 和 python3&amp;nbsp;的range函数，生成器的“惰性求值”特性使得不用开辟一个list，而只是在迭代中“现取现用”。&lt;/p&gt;
&lt;p&gt;我在使用中更有体验的经历是：写一个特殊格式的数据文件的parser，这种文件按特定大小的块增长，而每一条数据记录，存储在一条文件块的链表中。解析一条数据记录的逻辑是：现按照链表顺序拼合出连续缓存，再再缓存基础上解析数据记录，这样逻辑上是清晰的，但要再代码上照写逻辑，就是要单拿出一块很大的buffer，或者说拼合一个很大的列表，浪费空间，有效率的方法是，读到一个块，就可以解析此块上的数据记录，不过这样写，块的解析和记录的解析掺和到一个函数中，看上去很混乱（实际上原本有个C实现就是这样）。好的方法是，在解析block层面的函数ReadBlocks() 中 yield block，在解析数据记录的函数ReadRecs()中一个迭代中 &lt;code&gt;for block in ReadBlocks():&lt;/code&gt;处理Record的解析就好。我写这个工具中文件解析的实际代码在&amp;nbsp;https://github.com/lostsummer/emdfparse/blob/master/emdfparse/datafile.py&lt;/p&gt;
&lt;h3&gt;2.&amp;nbsp;递归结构中减少全局变量&lt;/h3&gt;
&lt;p&gt;比方某一类算法问题需要你对图作深度或广度遍历，得出所有符合条件的路径，这不避免的需要一个全局或者闭包的List存储这些路径，而有了 yield 和 yield from，大可不用这个全局变量，写出的函数更有“状态机”的意味。这里有我为两个算法题写的代码 https://github.com/lostsummer/fun 。一个是连接奶牛的路径问题，一个是组合问题，对这类问题，我很愿意把 yield from&amp;nbsp;当作一个范式来用，代码行数更少，思路更简明。&lt;/p&gt;
&lt;h3&gt;3.&amp;nbsp;协程范式&lt;/h3&gt;
&lt;p&gt;早在2009年，David Beazley 就写了 A Curious Course on Coroutines and Concurrency （http://www.dabeaz.com/coroutines/）我觉得读透所有技巧和思想对现在的写python程序也是很有帮助，尤其是理解复杂的asyncio。我觉得，不管是 &lt;code&gt;yield&lt;/code&gt; 还是 &lt;code&gt;x = yield&lt;/code&gt;都可以算是协程，了解golang的同学会说，这不就是只读channel和只写channel吗？但是，单一个yield还构不成协程管理的全部，单靠协程，asyncio，还构不成完整的并发模型。在CSP、actor都整合到GoLang和ErLang语言层面的时代，Py界还在犹豫到底拥抱asyncio还是愉快的用着gevent。我觉得，还是先用go吧。但是作为py异步编程的未来，asyncio值得研究，即使不学asyncio，那些使用协程解决问题的思路，也能给我们很多新的启发。关于py的协程，有很多可说，来日再开篇幅。&lt;/p&gt;</content><category term="Learning"></category><category term="Python"></category></entry><entry><title>与蟒共舞</title><link href="http://www.lostsummer.love/posts/2018/Nov/22/201811221843.html" rel="alternate"></link><published>2018-11-22T00:00:00+08:00</published><updated>2018-11-22T00:00:00+08:00</updated><author><name>Yushin</name></author><id>tag:www.lostsummer.love,2018-11-22:/posts/2018/Nov/22/201811221843.html</id><summary type="html">&lt;p&gt;2011年参加在上海举办的第一届PyCon&amp;nbsp;China时，没想到Python如今会成为“显学”，不要说大数据、人工智能这些热门职位都在招Python开发人员，就连“少儿编程”培训都在以这门语言为招牌。不由得感 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2011年参加在上海举办的第一届PyCon&amp;nbsp;China时，没想到Python如今会成为“显学”，不要说大数据、人工智能这些热门职位都在招Python开发人员，就连“少儿编程”培训都在以这门语言为招牌。不由得感叹，潮流来的太快，上车虽然早，却也没得到潮流上涨的红利。&lt;/p&gt;
&lt;p&gt;第一届PyCon&amp;nbsp;China的小众氛围有点类似中国早期的摇滚音乐节，因为只有上海一个会场，所以全国的Pythoneer汇聚一堂，台也都是大家耳熟能详的圈内大牛。因为小众所以自豪和抱团，分享的内容即使简单但也有趣和闪光，“人生苦短，我用Python”，这种用了都说好的演讲一多，就仿佛在团体传教现场:)。每个程序员都知道阿北在星巴克写出第一版豆瓣网的故事，而且作为豆瓣的拥趸，他们每个人似乎都是文艺青年。门票没记错的话只有60，包两天两顿披萨，送T恤和纪念品，的确不是为赚钱而是为情怀，相比而言，现在Gopher大会1千多的门票让人难以理解。&lt;/p&gt;
&lt;p&gt;据说第三届以后演讲的嘉宾换了一拨，几乎是大数据专场，我最近参加PyCon&amp;nbsp;Shanghai是2018年，几乎是人工智能专场，应该说圈子的变化反映了行业趋势的变化。一门入门门槛并不高的语言，配合这么火的技术潮流，想小众都难。金融精英，研究人工智能的硕士博士，写起Python代码来，丝毫不会逊色于码农。圈子已经变成江湖，强者如云，作为工具的编程语言本身并不能给你贴金，用工具做了多少事情才体现使用者的段位。&lt;/p&gt;
&lt;p&gt;但是与技术媒体、开发者大会上的如火如荼不相称的是，很多公司对Python的认知很浅。“Python不就是做点自动化吗”，“用Python做Web的很少吧，一般不都是PHP吗”，说这些话的面试者有海归创业者，有当大学教授的老板，搞得我每次都搬出“豆瓣”，然后默默嘀咕，把Python写在简历上究竟给我增加多少砝码？到是有不少这样的场景，前Java开发已转销售的大佬看到我屏幕上的代码，兴奋地问：“你会Python啊，那你懂不懂Hadoop？” 这是因为他参加了一些大数据的技术大会，感觉找到了公司发展的方向；或者某位产品发现你写Python，赶紧拿出一个脚本，说运行不起来请我帮忙调调，“你这个不是在电脑上本地运行的吧？”，他这才支支吾吾的告诉我，是在某量化平台的网站上运行的；还有我本科水利系的同学，当年写Fortran、VB也是一把好手，现在苦于新系统装不了VB6，&lt;span class="caps"&gt;VB&lt;/span&gt;.Net开发环境太笨重，我告诉他，“别想VB了，我给你介绍一位新朋友……”，我只是这么一介绍，基本上人家一个月就玩得很熟了。&lt;/p&gt;
&lt;p&gt;Python这扇门，让更多的软件行业外的人闯入代码世界，行业内的人面对这扇门多少显得顽固和固步自封。金融机构，开发平台用小型机的，很多还是用Perl做集成和测试，Perl也是个好的选择，尤其是没有Python时。我写过很多Perl脚本，但是坦白说现在语法都忘差不多了，这种事一定不会发生在Python上；Linux技术主导的公司，基本上都会用Python，但是一定也有“Java 一切”的；还有很多的公司对软件的认识还是“桌面为王”，对Linux的态度是“不得不搞&amp;#8221;，那很可能是“&lt;span class="caps"&gt;VC&lt;/span&gt;++ 一切”，情况比“Java 一切”还可怖。开发可能比测试还更难接受新的语言工具，“编程语言都差不多”，&amp;nbsp;或者拿运行效率回怼你的安利。那怎么向开发安利Python？你只要用你的Python做事半功倍的事即可，“我这边原型好了，这个接口你可以用来测了，你大概什么时候好？&amp;#8221;，”这个原型抗得住2w并发，docker打个包上线直接就可以用了”。用不了多久，你就会发现你的同事主动过来说，“这个需求我想用Python实现&amp;#8230;&amp;#8230;&amp;#8221;&lt;/p&gt;
&lt;p&gt;写到这里会心一笑，但是人流涌上之时，应该是再加速向前的时候了。编程语言并不都一样，我无法在掌握了元编程、装饰器、生成器、协程、asyncio这些炫酷的特性之后，写了十分之一代码解决同样的问题，并且十分享受这个过程之后，还能说服自己”和写C没什么区别“。但是在更高的认知层面，“目前为止只有两种真正干净利落, 始终如一的编程模式:C语言模式和Lisp语言模式”，我需要进入函数式编程的神奇世界，从兴趣和工业实践的经验来看，我希望这个世界的第一扇门是ErLang。虽然从实用角度，Go&amp;nbsp;是解决并发问题中值得使用的语言，但是我觉得表达简洁、清晰上还是不够，它也不会是在思想上会给我带来“洗礼”的编程语言，我觉得ErLang会是。&lt;/p&gt;</content><category term="Recommendation"></category></entry><entry><title>使用tmux和watch组合一个redis监控面板</title><link href="http://www.lostsummer.love/posts/2018/Oct/22/201810221843.html" rel="alternate"></link><published>2018-10-22T00:00:00+08:00</published><updated>2018-10-22T00:00:00+08:00</updated><author><name>Yushin</name></author><id>tag:www.lostsummer.love,2018-10-22:/posts/2018/Oct/22/201810221843.html</id><summary type="html">&lt;p&gt;对于开发来说，有些特定服务器数据的实时监控可以不必大而全，比方阮一峰 &lt;a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html"&gt;WebSocket 教程&lt;/a&gt;中提到的使用Websocketd +&amp;nbsp;简单脚本实现的对 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;对于开发来说，有些特定服务器数据的实时监控可以不必大而全，比方阮一峰 &lt;a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html"&gt;WebSocket 教程&lt;/a&gt;中提到的使用Websocketd +&amp;nbsp;简单脚本实现的对服务器性能指标的监控服务程序。而我现在自己有个需求更加简单，只要验证redis中几个key的数据是否在不断更新。我既不想自己不断刷新桌面redis客户端，也不想不断在cli里敲回车，实际上借助几个命令也可以非常简单地满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redis-cli：输出指定key的值&lt;/li&gt;
&lt;li&gt;watch：连续调用指定面命，并把输出刷新到屏幕上，类似top、tailf那样的效果，它是独占终端屏幕的&lt;/li&gt;
&lt;li&gt;tmux：会话保持、分屏。有了tmux就可以在一个平面查看多个watch命令的实时输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是有了下面的脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;HOST&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;127&lt;/span&gt;.0.0.1
&lt;span class="nv"&gt;PORT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;6379&lt;/span&gt;
&lt;span class="nv"&gt;DB&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;

&lt;span class="nv"&gt;R_CONN&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;redis-cli -h &lt;/span&gt;&lt;span class="nv"&gt;$HOST&lt;/span&gt;&lt;span class="s2"&gt; -p &lt;/span&gt;&lt;span class="nv"&gt;$PORT&lt;/span&gt;&lt;span class="s2"&gt; -n &lt;/span&gt;&lt;span class="nv"&gt;$DB&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;R_MIN1_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;lrange min1:0600000 -1 -1&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;R_CMINFO_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;get codemap:info&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;R_CMLEN_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hlen codemap:codes&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;R_QUOTE_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;get quote:0600000&amp;quot;&lt;/span&gt;

&lt;span class="nv"&gt;WATCH_MIN1_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;watch \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$R_CONN&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$R_MIN1_CMD&lt;/span&gt;&lt;span class="s2"&gt;|python -m json.tool\&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;WATCH_CMINFO_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;watch \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$R_CONN&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$R_CMINFO_CMD&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;WATCH_CMLEN_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;watch \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$R_CONN&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$R_CMLEN_CMD&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;WATCH_QUOTE_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;watch \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$R_CONN&lt;/span&gt;&lt;span class="s2"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$R_QUOTE_CMD&lt;/span&gt;&lt;span class="s2"&gt;|python -m json.tool|grep time\&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="nv"&gt;SESS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;monitor

tmux&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;-t&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$SESS&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-ne&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;tmux&lt;span class="w"&gt; &lt;/span&gt;new-session&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$SESS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WATCH_MIN1_CMD&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;split-window&lt;span class="w"&gt; &lt;/span&gt;-h&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WATCH_CMINFO_CMD&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;split-window&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WATCH_CMLEN_CMD&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt;-pane&lt;span class="w"&gt; &lt;/span&gt;-R&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;split-window&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WATCH_QUOTE_CMD&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;attach
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要说明的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;watch 默认刷新的频率是2s，这个可以通过 -n 指定，watch 还有个 -d&amp;nbsp;选项会高亮刷新后的差异部分&lt;/li&gt;
&lt;li&gt;python -m json.tool&amp;nbsp;会把压缩的json格式化成美观可读的样式&lt;/li&gt;
&lt;li&gt;tmux 大家可能已经熟悉分屏操作的快捷键，这些操作其实在启动session时可以通过一连串的命令定义，这些命令之间需要&lt;code&gt;' \; '&lt;/code&gt;分隔&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;脚本运行效果是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mon" src="http://140.143.250.15/wiki-img/tmux_mon.png"&gt;&lt;/p&gt;</content><category term="Learning"></category></entry></feed>